
## java基础问题汇总
1. 访问权限有哪些，区别；
2. 进程间通信方式（IPC）；
3. jvm内存管理，垃圾回收机制；回收算法；
4. java的四个引用方式与区别；
5. java动态代理机制；
6. AIDL内部有哪些方法；
7. ArrayList 和 LinkedList 区别
8. LRUCache 是如何实现的（源码角度）？为什么要用 LinkedHashmap？
   LRUCache内部采用LinkedHashmap结构，当get的时候，LinkedHashmap会把get的元素放在队尾；
   LRUCache达到最大缓存数量时，会删除头结点，即最少使用的元素；

### 1. 访问权限有哪些，区别；

java的访问权限有四种，区别如下：
|   |类内部|包内部|子类|外部包|
|:--|:-:|:-:|:-:|:-:|
|public|Y|Y|Y|Y|
|protected|Y|Y|Y|N|
|默认|Y|Y|N|N|
|private|Y|N|N|N|

### 2. 进程间通信方式（IPC）及对比；

|名称|优点|缺点|适用场景|
|:--|:-|:-|:-|:-|
| Bundle|简单易用 |只能传输Bundle支持的类型 |四大组件之间的进程通信 |
|文件共享|简单易用|不适合高并发场景，并且无法做到进程间<br>即时通信| 无并发访问情形，交换简单的数据，<br>实时性不高的场景|
|AIDL|功能强大，支持一对多并发操作、实时通信|使用复杂，需要处理好线程同步|一对多通信且有RPC需求|
|Messenger|功能一般，支持一对多串行通信、实时通信|不能很好地额处理高并发情景，<br>不支持rpc，只能传输bundle支持的类型|低并发的一对多即时通信|
|ContentProvider|数据访问功能强大，支持一对多并发数据<br>共享，可通过call方式扩展其他操作|可以理解为受约束的aidl，<br>主要提供数据源CRUD操作|一对多进程间的数据共享|
|Socket|功能强大，可以通过网络传输字节流，<br>支持一对多并发实时通信|实现细节稍微繁琐，不支持直接RPC|网络数据交换|


### 3. jvm内存管理，垃圾回收机制；回收算法；

#### 3.1 jvm模型：

|:-|:-:|:-
程序计数器|线程私有 |是一小块内存空间，记录当前线程所执行的字节码行号指示器。
java虚拟机|线程私有 |java方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧。
本地方法栈|线程私有 |Native方法
java堆|线程共享 |可以处于物理上不连续的内存空间
方法区|线程共享 |用于存储已被虚拟机加载的类信息、常量、静态变量。

#### 3.2 如何判断那些内存需要回收？
3.2.1 引用计数法
引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，
且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，
计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，
对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集

优点：
引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。

缺点：
无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.

#### 3.2.2 根搜索算法（可达性分析法）
根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节
点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用
到的节点，即无用的节点。

java中可作为GC Root的对象有（关于引用见问题4）：

-1.虚拟机栈中引用的对象（本地变量表）
-2.方法区中静态属性引用的对象
-3. 方法区中常量引用的对象
-4.本地方法栈中引用的对象（Native对象）

#### 3.3 常用垃圾收集器

-1) 标记-清除收集器 Mark-Sweep
标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标
记的对象所占用的空间。

-2) 复制收集器        Copying　　
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另
外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。

-3) 标记-压缩收集器 Mark-Compact
该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后
清理掉端边界以外的内存。

-4) 分代收集器　　　Generational
分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的
区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾
收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点
采取最适合的收集算法。
目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的
操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和
两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对
象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。
而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。

4. java的四个引用方式与区别；

-强引用：只要存在，垃圾收集器就不会回收对象。
```
Object obj = new Object();之类
```
-软引用：用来描述一些还有用但是不必须的对象，系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行
第二次回收，如果还是不够那就只能抛出内存溢出的异常了。
```
SoftReference<String>s = new SoftReference<>(“我还有用但不是必须的!”);
```
-弱引用：用来描述非必须对象，但是强度比弱引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，垃圾收集
工作的时候，无论是否必要都会回收掉只被弱引用关联的对象。
```
WeakReference<String>s = new WeakReference<String>(“我只能活到下一次垃圾收集之前”);
```
-虚引用（幽灵引用或幻影引用）：一个对象是否有虚引用，与其生命周期毫无关系，也无法通过虚引用取得一个对象实例，只
被虚引用的对象，随时都会被回收掉
```
PhantomReference<String>ref = new PhantomReference<String>(“我只能接受死亡通知”) , targetReferenceQueue<String>);
```

5. java动态代理机制；
6. AIDL内部有哪些方法；
7. ArrayList 和 LinkedList 区别
8. LRUCache 是如何实现的（源码角度）？为什么要用 LinkedHashmap？
   LRUCache内部采用LinkedHashmap结构，当get的时候，LinkedHashmap会把get的元素放在队尾；
   LRUCache达到最大缓存数量时，会删除头结点，即最少使用的元素；


